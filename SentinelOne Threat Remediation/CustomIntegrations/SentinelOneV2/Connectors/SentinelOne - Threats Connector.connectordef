{
  "IsEnabled": true,
  "IsCustom": true,
  "Integration": "SentinelOneV2",
  "DocumentationLink": null,
  "Name": "SentinelOne - Threats Connector",
  "Description": "Fetch the leteast threats from SentinelOne.",
  "Creator": "Admin",
  "Script": "from SiemplifyUtils import output_handler\n# ==============================================================================\n# title           :ThreatsConnector.py\n# description     :This Module contain SentinelOneV2 threats Connector logic.\n# author          :victor@siemplify.co\n# date            :28-11-2018\n# python_version  :2.7\n# libraries       : -\n# requirements    :\n# product_version : Eiffel\n# ==============================================================================\n# =====================================\n#              IMPORTS                #\n# =====================================\nfrom SentinelOneV2Manager import SentinelOneV2Manager\nfrom SiemplifyConnectors import SiemplifyConnectorExecution, CaseInfo\nfrom SiemplifyUtils import convert_string_to_unix_time, dict_to_flat, utc_now\nfrom TIPCommon import extract_connector_param\nfrom EnvironmentCommon import EnvironmentHandle\nimport uuid\nimport sys\nimport datetime\nimport os\nimport json\n\n# =====================================\n#             CONSTANTS               #\n# =====================================\nEVENT_CREATION_TIME_FIELD = 'agent_createdAt'\nDEFAULT_PRODUCT = 'SentinelOne'\nMAP_FILE = u\"map.json\"\n\nEVENT_TIME_FIELD = 'createdAt'\nTHREAT_DESCRIPTION_FIELD = 'description'\nTHREAT_NAME_FIELD = \"threatName\"\nTHREAT_ID_FIELD = \"id\"\n\nALERT_WITHOUT_A_RULE_DEFAULT = 'Alert has no rule.'\nALERT_WITHOUT_A_NAME_DEFAULT = 'Alert has no name.'\nTHREAT_NAME_IS_EMPTY_DEFAULT = \"Threat name is empty.\"\n\n\n# =====================================\n#              CLASSES                #\n# =====================================\nclass SentinelOneV2ThreatsConnectorError(Exception):\n    pass\n\n\nclass SentinelOneV2ThreatsConnector(object):\n    def __init__(self, connector_scope, environment_field_name, environment_regex, logger):\n        self.connector_scope = connector_scope\n        self.logger = logger\n\n        map_file_path = os.path.join(connector_scope.run_folder, MAP_FILE)\n        connector_scope.LOGGER.info(u\"Validating environments mapping file at: {}\".format(map_file_path))\n        self.validate_map_file(map_file_path)\n\n        connector_scope.LOGGER.info(u\"Loading EnvironmentCommon\")\n        self.environment_common = EnvironmentHandle(map_file_path, self.logger, environment_field_name,\n                                                    environment_regex,\n                                                    connector_scope.context.connector_info.environment)\n\n    def validate_map_file(self, map_file_path):\n        \"\"\"\n        Validate the existence of the environment mapping file\n        :param map_file_path: {str} The path to the map file\n        \"\"\"\n        try:\n            if not os.path.exists(map_file_path):\n                with open(map_file_path, 'w+') as map_file:\n                    map_file.write(json.dumps(\n                        {u\"Original environment name\": u\"Desired environment name\",\n                         u\"Env1\": u\"MyEnv1\"}))\n                    self.logger.info(\n                        u\"Mapping file was created at {}\".format(map_file_path)\n                    )\n\n        except Exception as e:\n            self.logger.error(u\"Unable to create mapping file: {}\".format(e))\n            self.logger.exception(e)\n\n    @staticmethod\n    def validate_timestamp_offset(datetime_timestamp, offset_in_days=2):\n        \"\"\"\n        Validate if timestamp in offset range.\n        :param datetime_timestamp: timestamp that were fetched from the timestamp file {datetime}\n        :param offset_in_days: the offset in days to validate {string}\n        :return: unixtime: if time not in offset return offset time {string}\n        \"\"\"\n        offset_datetime = utc_now() - datetime.timedelta(days=offset_in_days)\n\n        if datetime_timestamp <= offset_datetime:\n            return offset_datetime\n        return datetime_timestamp\n\n    def convert_threat_time_to_unixtime(self, string_time):\n        \"\"\"\n        Convert threat time from string format to unixtime.\n        :param string_time: {stirng} Time string.\n        :return: {long} Time unixtime.\n        \"\"\"\n        try:\n            return convert_string_to_unix_time(string_time)\n        except Exception as err:\n            error_message = \"Failed to convert threat time, ERROR: {0}\".format(err.message)\n            self.logger.error(error_message)\n            self.logger.exception(err)\n            return 1\n\n    def create_case(self, threat, device_product_field):\n        \"\"\"\n        Create a case object.\n        :return: {CaseInfo} Case object.\n        \"\"\"\n        case_info = CaseInfo()\n        case_info.start_time = case_info.end_time = self.convert_threat_time_to_unixtime(threat.get(EVENT_TIME_FIELD))\n        case_info.rule_generator = threat.get(THREAT_DESCRIPTION_FIELD, ALERT_WITHOUT_A_RULE_DEFAULT)\n        case_info.device_product = threat.get(device_product_field, DEFAULT_PRODUCT)\n        case_info.device_vendor = case_info.device_product\n        case_info.environment = self.environment_common.get_environment(threat)\n\n        case_info.name = threat.get(THREAT_NAME_FIELD, ALERT_WITHOUT_A_NAME_DEFAULT) \\\n            if threat.get(THREAT_NAME_FIELD) else THREAT_NAME_IS_EMPTY_DEFAULT\n\n        # If no Session ID, replace with timestamp + uuid because timestamp can be not unique in some cases.\n        case_info.ticket_id = threat.get(THREAT_ID_FIELD, \"{0}_{1}\".format(case_info.start_time,\n                                                                           str(uuid.uuid4())))\n\n        case_info.display_id = case_info.identifier = case_info.ticket_id\n        case_info.events = [dict_to_flat(threat)]\n\n        return case_info\n\n\n@output_handler\ndef main(test_handler=False):\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n    cases = []\n    whole_cases_list = []\n\n    try:\n        if test_handler:\n            connector_scope.LOGGER.info(\" ------------ Starting SentinelOneV2 Threats Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Starting Connector. ------------ \")\n\n        api_root = extract_connector_param(connector_scope, u\"API Root\", is_mandatory=True)\n        api_token = extract_connector_param(connector_scope, u\"API Token\", is_mandatory=True)\n        verify_ssl = extract_connector_param(connector_scope, u\"Verify SSL\", is_mandatory=True, input_type=bool)\n        max_days_backwards = extract_connector_param(connector_scope, param_name=u\"Fetch Max Days Backwards\",\n                                                     is_mandatory=False, default_value=1, input_type=int,\n                                                     print_value=True)\n        device_product_field = extract_connector_param(connector_scope, u\"DeviceProductField\", is_mandatory=True)\n        environment_field_name = extract_connector_param(connector_scope, param_name=u\"Environment Field Name\",\n                                                         is_mandatory=False, input_type=unicode, print_value=True)\n        environment_regex = extract_connector_param(connector_scope, param_name=u\"Environment Regex Pattern\",\n                                                    is_mandatory=False, input_type=unicode, print_value=True)\n\n        sentinel_manager = SentinelOneV2Manager(api_root, api_token, verify_ssl)\n        sentinel_connector = SentinelOneV2ThreatsConnector(connector_scope, environment_field_name, environment_regex,\n                                                           connector_scope.LOGGER)\n\n        last_run_time = sentinel_connector.validate_timestamp_offset(\n            connector_scope.fetch_timestamp(datetime_format=True),\n            max_days_backwards)\n\n        threats = sentinel_manager.get_unresolved_threats_by_time(last_run_time)\n\n        threats = map(dict_to_flat, threats)\n\n        if test_handler:\n            threats = threats[-1:]\n\n        for threat in threats:\n            try:\n                agent_id = threat.get('agentId')\n\n                if agent_id:\n                    connector_scope.LOGGER.info(\n                        \"Retrieving agent information for threat with id: {0}\".format(threat.get(THREAT_ID_FIELD)))\n                    agent_info = sentinel_manager.get_agent_by_id(agent_id)\n                    threat['agent'] = agent_info.to_json()\n\n                connector_scope.LOGGER.info(\"Creating case for threat with id: {0}\".format(threat.get(THREAT_ID_FIELD)))\n                case = sentinel_connector.create_case(\n                    threat,\n                    device_product_field=device_product_field)\n                whole_cases_list.append(case)\n\n                is_overflowed = False\n\n                try:\n                    is_overflowed = connector_scope.is_overflowed_alert(\n                        environment=case.environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product))\n\n                except Exception as err:\n                    connector_scope.LOGGER.error(\n                        'Error validation connector overflow, ERROR: {0}'.format(unicode(err)))\n                    connector_scope.LOGGER.exception(err)\n                    if test_handler:\n                        raise\n\n                if is_overflowed:\n                    connector_scope.LOGGER.info(\n                        \"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.\"\n                            .format(alert_name=str(case.rule_generator),\n                                    alert_identifier=str(case.ticket_id),\n                                    environment=str(case.environment),\n                                    product=str(case.device_product)))\n                else:\n                    cases.append(case)\n                    connector_scope.LOGGER.info('Case with display id \"{0}\" was created.'.format(case.display_id))\n\n            except Exception as err:\n                error_message = \"Failed creating case for threat with ID: {0}, ERROR: {1}\".format(\n                    threat.get(THREAT_ID_FIELD),\n                    err.message\n                )\n                connector_scope.LOGGER.error(error_message)\n                connector_scope.LOGGER.exception(err)\n                if test_handler:\n                    raise\n\n        whole_cases_list.sort(key=lambda x: x.start_time)\n\n        if whole_cases_list and not test_handler:\n            connector_scope.save_timestamp(whole_cases_list[-1].start_time)\n\n        if test_handler:\n            connector_scope.LOGGER.info(\" ------------ Complete SentinelOneV2 Threat Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Complete Connector Iteration. ------------ \")\n\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as err:\n        connector_scope.LOGGER.error('Got exception on main handler. Error: {0}'.format(err))\n        connector_scope.LOGGER.exception(err)\n        if test_handler:\n            raise\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        main(test_handler=True)\n",
  "Version": 17,
  "MappingRules": [],
  "ProductToVisualFamilyRecords": [],
  "SimulationUseCases": {
    "CasesForUseCase": [],
    "UseCaseName": null
  },
  "Parameters": [
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "Proxy Password",
      "Type": 3,
      "Mode": 2,
      "Description": "The proxy password to authenticate with.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "Proxy Username",
      "Type": 2,
      "Mode": 2,
      "Description": "The proxy username to authenticate with.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "Proxy Server Address",
      "Type": 2,
      "Mode": 2,
      "Description": "The address of the proxy server to use.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": "1",
      "Name": "Fetch Max Days Backwards",
      "Type": 1,
      "Mode": 2,
      "Description": "",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": "TRUE",
      "Name": "Verify SSL",
      "Type": 0,
      "Mode": 2,
      "Description": "If enabled, verify the SSL certificate for the connection to the Sentinel public cloud server is valid.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": true,
      "DefaultValue": "",
      "Name": "API Token",
      "Type": 3,
      "Mode": 2,
      "Description": "SentinelOne API token.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": true,
      "DefaultValue": "",
      "Name": "API Root",
      "Type": 2,
      "Mode": 2,
      "Description": "Address of SentinelOne API root.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": true,
      "DefaultValue": "30",
      "Name": "PythonProcessTimeout",
      "Type": 2,
      "Mode": 0,
      "Description": "The timeout limit (in seconds) for the python process running current script",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": false,
      "DefaultValue": "classificationSource",
      "Name": "EventClassId",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the event name (sub-type)",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    },
    {
      "ConnectorDefinitionId": 1,
      "IsMandatory": true,
      "DefaultValue": "accountName",
      "Name": "DeviceProductField",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the device product",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1590908125471,
      "ModificationTimeUnixTimeInMs": 1590908125471
    }
  ],
  "Rules": [],
  "IsConnectorRulesSupported": false,
  "IsSystem": false,
  "PythonVersion": "None",
  "Id": 0,
  "CreationTimeUnixTimeInMs": 1588021981878,
  "ModificationTimeUnixTimeInMs": 1590908125462
}